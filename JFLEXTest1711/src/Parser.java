
//----------------------------------------------------
// The following code was generated by CUP v0.11a beta 20060608
// Mon Jan 11 16:14:10 IST 2016
//----------------------------------------------------

import java_cup.runtime.*;

/**
 * CU0P v0.11a beta 20060608 generated parser.
 * 
 * @version Mon Jan 11 16:14:10 IST 2016
 */
public class Parser extends java_cup.runtime.lr_parser {

	/** Default constructor. */
	public Parser() {
		super();
	}

	/** Constructor which sets the default scanner. */
	public Parser(java_cup.runtime.Scanner s) {
		super(s);
	}

	/** Constructor which sets the default scanner. */
	public Parser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {
		super(s, sf);
	}

	/** Production table. */
	protected static final short _production_table[][] = unpackFromStrings(
			new String[] { "\000\057\000\002\004\010\000\002\002\004\000\002\005"
					+ "\005\000\002\005\002\000\002\007\005\000\002\007\005"
					+ "\000\002\010\005\000\002\010\004\000\002\011\003\000"
					+ "\002\011\003\000\002\012\010\000\002\012\002\000\002"
					+ "\014\003\000\002\014\005\000\002\014\003\000\002\014"
					+ "\003\000\002\014\003\000\002\014\003\000\002\021\006"
					+ "\000\002\002\006\000\002\020\005\000\002\003\012\000"
					+ "\002\003\007\000\002\003\013\000\002\003\010\000\002"
					+ "\003\003\000\002\022\005\000\002\015\011\000\002\016"
					+ "\003\000\002\016\003\000\002\026\011\000\002\026\005"
					+ "\000\002\025\007\000\002\025\007\000\002\024\005\000"
					+ "\002\024\003\000\002\027\005\000\002\027\003\000\002"
					+ "\030\006\000\002\030\005\000\002\023\005\000\002\023"
					+ "\003\000\002\013\005\000\002\013\003\000\002\031\005" + "\000\002\031\003\000\002\031\003" });

	/** Access to production table. */
	public short[][] production_table() {
		return _production_table;
	}

	/** Parse-action table. */
	protected static final short[][] _action_table = unpackFromStrings(
			new String[] { "\000\036\000\004\016\005\001\002\000\004\002\040\001"
					+ "\002\000\002\001\002\000\004\026\007\001\002\000\004"
					+ "\031\010\001\002\000\002\001\002\000\002\001\002\000"
					+ "\004\030\013\001\002\000\004\002\001\001\002\000\004"
					+ "\006\027\001\002\000\004\025\016\001\002\000\006\024"
					+ "\017\025\021\001\002\000\002\001\002\000\004\006\ufffc"
					+ "\001\002\000\006\014\024\020\022\001\002\000\004\006"
					+ "\ufff8\001\002\000\004\006\ufffa\001\002\000\004\006\ufff9"
					+ "\001\002\000\006\024\017\025\021\001\002\000\004\006"
					+ "\ufffb\001\002\000\006\014\024\020\022\001\002\000\002"
					+ "\001\002\000\006\024\017\025\021\001\002\000\004\006"
					+ "\ufffd\001\002\000\002\001\002\000\004\044\035\001\002"
					+ "\000\004\035\036\001\002\000\004\006\027\001\002\000"
					+ "\002\001\002\000\004\002\000\001\002" });

	/** Access to parse-action table. */
	public short[][] action_table() {
		return _action_table;
	}

	/** <code>reduce_goto</code> table. */
	protected static final short[][] _reduce_table = unpackFromStrings(
			new String[] { "\000\036\000\004\004\003\001\001\000\002\001\001\000"
					+ "\004\017\005\001\001\000\002\001\001\000\004\005\010"
					+ "\001\001\000\006\007\013\017\014\001\001\000\004\006"
					+ "\011\001\001\000\002\001\001\000\002\001\001\000\006"
					+ "\012\027\017\030\001\001\000\002\001\001\000\004\010"
					+ "\017\001\001\000\004\017\024\001\001\000\002\001\001"
					+ "\000\004\011\022\001\001\000\002\001\001\000\002\001"
					+ "\001\000\002\001\001\000\004\010\025\001\001\000\002"
					+ "\001\001\000\004\011\032\001\001\000\002\001\001\000"
					+ "\004\010\031\001\001\000\002\001\001\000\004\017\033"
					+ "\001\001\000\002\001\001\000\002\001\001\000\004\012"
					+ "\036\001\001\000\002\001\001\000\002\001\001" });

	/** Access to <code>reduce_goto</code> table. */
	public short[][] reduce_table() {
		return _reduce_table;
	}

	/** Instance of action encapsulation class. */
	protected CUP$parser$actions action_obj;

	/** Action encapsulation object initializer. */
	protected void init_actions() {
		action_obj = new CUP$parser$actions(this);
	}

	/** Invoke a user supplied parse action. */
	public java_cup.runtime.Symbol do_action(int act_num, java_cup.runtime.lr_parser parser, java.util.Stack stack,
			int top) throws java.lang.Exception {
		/* call code in generated class */
		return action_obj.CUP$parser$do_action(act_num, parser, stack, top);
	}

	/** Indicates start state. */
	public int start_state() {
		return 0;
	}

	/** Indicates start production. */
	public int start_production() {
		return 1;
	}

	/** <code>EOF</code> Symbol index. */
	public int EOF_sym() {
		return 0;
	}

	/** <code>error</code> Symbol index. */
	public int error_sym() {
		return 1;
	}

	/** User initialization code. */
	public void user_init() throws java.lang.Exception {
		s.init();
	}

	// /** Scan to get the next Symbol. */
	// public Symbol scan() throws java.lang.Exception {
	// return Scanner.next_token();
	// }
	/** Scan to get the next Symbol. */
	public java_cup.runtime.Symbol scan() throws java.lang.Exception {
		return s.next_token();
	}

	// Connect this parser to a scanner!
	Scanner s;

	Parser(Scanner s) {
		this.s = s;
	}

	public boolean syntaxErrors;

	CplAnalyzer1 lexer;

	public Parser(CplAnalyzer1 lex, ComplexSymbolFactory sf) {
		super(lex, sf);
		lexer = lex;
	}

}

/** Cup generated class to encapsulate user supplied action code. */
class CUP$parser$actions {
	private final Parser parser;

	/** Constructor */
	CUP$parser$actions(Parser parser) {
		this.parser = parser;
	}

	/** Method with the actual generated action code. */
	public final java_cup.runtime.Symbol CUP$parser$do_action(int CUP$parser$act_num,
			java_cup.runtime.lr_parser CUP$parser$parser, java.util.Stack CUP$parser$stack, int CUP$parser$top)
					throws java.lang.Exception {
		/* Symbol object for return from actions */
		java_cup.runtime.Symbol CUP$parser$result;

		/* select the action based on the action number */
		switch (CUP$parser$act_num) {
		/* . . . . . . . . . . . . . . . . . . . . */
		case 46: // factor ::= NUM
		{
			Object RESULT = null;

			CUP$parser$result = parser.getSymbolFactory().newSymbol("factor", 23,
					((java_cup.runtime.Symbol) CUP$parser$stack.peek()),
					((java_cup.runtime.Symbol) CUP$parser$stack.peek()), RESULT);
		}
			return CUP$parser$result;

		/* . . . . . . . . . . . . . . . . . . . . */
		case 45: // factor ::= id
		{
			Object RESULT = null;

			CUP$parser$result = parser.getSymbolFactory().newSymbol("factor", 23,
					((java_cup.runtime.Symbol) CUP$parser$stack.peek()),
					((java_cup.runtime.Symbol) CUP$parser$stack.peek()), RESULT);
		}
			return CUP$parser$result;

		/* . . . . . . . . . . . . . . . . . . . . */
		case 44: // factor ::= LBRECKET expression RBRECKET
		{
			Object RESULT = null;

			CUP$parser$result = parser.getSymbolFactory().newSymbol("factor", 23,
					((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top - 2)),
					((java_cup.runtime.Symbol) CUP$parser$stack.peek()), RESULT);
		}
			return CUP$parser$result;

		/* . . . . . . . . . . . . . . . . . . . . */
		case 43: // term ::= factor
		{
			Object RESULT = null;

			CUP$parser$result = parser.getSymbolFactory().newSymbol("term", 9,
					((java_cup.runtime.Symbol) CUP$parser$stack.peek()),
					((java_cup.runtime.Symbol) CUP$parser$stack.peek()), RESULT);
		}
			return CUP$parser$result;

		/* . . . . . . . . . . . . . . . . . . . . */
		case 42: // term ::= term MULOP factor
		{
			Object RESULT = null;

			CUP$parser$result = parser.getSymbolFactory().newSymbol("term", 9,
					((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top - 2)),
					((java_cup.runtime.Symbol) CUP$parser$stack.peek()), RESULT);
		}
			return CUP$parser$result;

		/* . . . . . . . . . . . . . . . . . . . . */
		case 41: // expression ::= term
		{
			Object RESULT = null;

			CUP$parser$result = parser.getSymbolFactory().newSymbol("expression", 17,
					((java_cup.runtime.Symbol) CUP$parser$stack.peek()),
					((java_cup.runtime.Symbol) CUP$parser$stack.peek()), RESULT);
		}
			return CUP$parser$result;

		/* . . . . . . . . . . . . . . . . . . . . */
		case 40: // expression ::= expression ADDOP term
		{
			Object RESULT = null;

			CUP$parser$result = parser.getSymbolFactory().newSymbol("expression", 17,
					((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top - 2)),
					((java_cup.runtime.Symbol) CUP$parser$stack.peek()), RESULT);
		}
			return CUP$parser$result;

		/* . . . . . . . . . . . . . . . . . . . . */
		case 39: // boolfactor ::= expression RELOP expression
		{
			Object RESULT = null;

			CUP$parser$result = parser.getSymbolFactory().newSymbol("boolfactor", 22,
					((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top - 2)),
					((java_cup.runtime.Symbol) CUP$parser$stack.peek()), RESULT);
		}
			return CUP$parser$result;

		/* . . . . . . . . . . . . . . . . . . . . */
		case 38: // boolfactor ::= FACTORIAL LBRECKET boolfactor RBRECKET
		{
			Object RESULT = null;

			CUP$parser$result = parser.getSymbolFactory().newSymbol("boolfactor", 22,
					((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top - 3)),
					((java_cup.runtime.Symbol) CUP$parser$stack.peek()), RESULT);
		}
			return CUP$parser$result;

		/* . . . . . . . . . . . . . . . . . . . . */
		case 37: // boolterm ::= boolfactor
		{
			Object RESULT = null;

			CUP$parser$result = parser.getSymbolFactory().newSymbol("boolterm", 21,
					((java_cup.runtime.Symbol) CUP$parser$stack.peek()),
					((java_cup.runtime.Symbol) CUP$parser$stack.peek()), RESULT);
		}
			return CUP$parser$result;

		/* . . . . . . . . . . . . . . . . . . . . */
		case 36: // boolterm ::= boolterm ANDOP boolfactor
		{
			Object RESULT = null;

			CUP$parser$result = parser.getSymbolFactory().newSymbol("boolterm", 21,
					((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top - 2)),
					((java_cup.runtime.Symbol) CUP$parser$stack.peek()), RESULT);
		}
			return CUP$parser$result;

		/* . . . . . . . . . . . . . . . . . . . . */
		case 35: // boolexpr ::= boolterm
		{
			Object RESULT = null;

			CUP$parser$result = parser.getSymbolFactory().newSymbol("boolexpr", 18,
					((java_cup.runtime.Symbol) CUP$parser$stack.peek()),
					((java_cup.runtime.Symbol) CUP$parser$stack.peek()), RESULT);
		}
			return CUP$parser$result;

		/* . . . . . . . . . . . . . . . . . . . . */
		case 34: // boolexpr ::= boolexpr OROP boolterm
		{
			Object RESULT = null;

			CUP$parser$result = parser.getSymbolFactory().newSymbol("boolexpr", 18,
					((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top - 2)),
					((java_cup.runtime.Symbol) CUP$parser$stack.peek()), RESULT);
		}
			return CUP$parser$result;

		/* . . . . . . . . . . . . . . . . . . . . */
		case 33: // step ::= id ASSIGNOP id MULOP NUM
		{
			Object RESULT = null;

			CUP$parser$result = parser.getSymbolFactory().newSymbol("step", 19,
					((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top - 4)),
					((java_cup.runtime.Symbol) CUP$parser$stack.peek()), RESULT);
		}
			return CUP$parser$result;

		/* . . . . . . . . . . . . . . . . . . . . */
		case 32: // step ::= id ASSIGNOP id ADDOP NUM
		{
			Object RESULT = null;

			CUP$parser$result = parser.getSymbolFactory().newSymbol("step", 19,
					((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top - 4)),
					((java_cup.runtime.Symbol) CUP$parser$stack.peek()), RESULT);
		}
			return CUP$parser$result;

		/* . . . . . . . . . . . . . . . . . . . . */
		case 31: // cases ::= DEFAULT COLON stmtlist
		{
			Object RESULT = null;

			CUP$parser$result = parser.getSymbolFactory().newSymbol("cases", 20,
					((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top - 2)),
					((java_cup.runtime.Symbol) CUP$parser$stack.peek()), RESULT);
		}
			return CUP$parser$result;

		/* . . . . . . . . . . . . . . . . . . . . */
		case 30: // cases ::= CASE NUM COLON stmtlist BREAK SEMICOLON cases
		{
			Object RESULT = null;

			CUP$parser$result = parser.getSymbolFactory().newSymbol("cases", 20,
					((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top - 6)),
					((java_cup.runtime.Symbol) CUP$parser$stack.peek()), RESULT);
		}
			return CUP$parser$result;

		/* . . . . . . . . . . . . . . . . . . . . */
		case 29: // choice ::= NUM
		{
			Object RESULT = null;

			CUP$parser$result = parser.getSymbolFactory().newSymbol("choice", 12,
					((java_cup.runtime.Symbol) CUP$parser$stack.peek()),
					((java_cup.runtime.Symbol) CUP$parser$stack.peek()), RESULT);
		}
			return CUP$parser$result;

		/* . . . . . . . . . . . . . . . . . . . . */
		case 28: // choice ::= id
		{
			Object RESULT = null;

			CUP$parser$result = parser.getSymbolFactory().newSymbol("choice", 12,
					((java_cup.runtime.Symbol) CUP$parser$stack.peek()),
					((java_cup.runtime.Symbol) CUP$parser$stack.peek()), RESULT);
		}
			return CUP$parser$result;

		/* . . . . . . . . . . . . . . . . . . . . */
		case 27: // switch ::= switch LBRECKET choice RBRECKET LCBRECKET cases
					// RCBRECKET
		{
			Object RESULT = null;

			CUP$parser$result = parser.getSymbolFactory().newSymbol("switch", 11,
					((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top - 6)),
					((java_cup.runtime.Symbol) CUP$parser$stack.peek()), RESULT);
		}
			return CUP$parser$result;

		/* . . . . . . . . . . . . . . . . . . . . */
		case 26: // stmt_block ::= LCBRECKET stmtlist RCBRECKET
		{
			Object RESULT = null;

			CUP$parser$result = parser.getSymbolFactory().newSymbol("stmt_block", 16,
					((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top - 2)),
					((java_cup.runtime.Symbol) CUP$parser$stack.peek()), RESULT);
		}
			return CUP$parser$result;

		/* . . . . . . . . . . . . . . . . . . . . */
		case 25: // control_stmt ::= switch
		{
			Object RESULT = null;

			CUP$parser$result = parser.getSymbolFactory().newSymbol("control_stmt", 1,
					((java_cup.runtime.Symbol) CUP$parser$stack.peek()),
					((java_cup.runtime.Symbol) CUP$parser$stack.peek()), RESULT);
		}
			return CUP$parser$result;

		/* . . . . . . . . . . . . . . . . . . . . */
		case 24: // control_stmt ::= DO stmt_block TILL LBRECKET boolexpr
					// RBRECKET
		{
			Object RESULT = null;

			CUP$parser$result = parser.getSymbolFactory().newSymbol("control_stmt", 1,
					((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top - 5)),
					((java_cup.runtime.Symbol) CUP$parser$stack.peek()), RESULT);
		}
			return CUP$parser$result;

		/* . . . . . . . . . . . . . . . . . . . . */
		case 23: // control_stmt ::= FOR LBRECKET assignment_stmt SEMICOLON
					// boolexpr SEMICOLON step RBRECKET stmt
		{
			Object RESULT = null;

			CUP$parser$result = parser.getSymbolFactory().newSymbol("control_stmt", 1,
					((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top - 8)),
					((java_cup.runtime.Symbol) CUP$parser$stack.peek()), RESULT);
		}
			return CUP$parser$result;

		/* . . . . . . . . . . . . . . . . . . . . */
		case 22: // control_stmt ::= WHILE LBRECKET boolexpr RBRECKET stmt_block
		{
			Object RESULT = null;

			CUP$parser$result = parser.getSymbolFactory().newSymbol("control_stmt", 1,
					((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top - 4)),
					((java_cup.runtime.Symbol) CUP$parser$stack.peek()), RESULT);
		}
			return CUP$parser$result;

		/* . . . . . . . . . . . . . . . . . . . . */
		case 21: // control_stmt ::= IF LBRECKET boolexpr RBRECKET THEN stmt
					// ELSE stmt
		{
			Object RESULT = null;

			CUP$parser$result = parser.getSymbolFactory().newSymbol("control_stmt", 1,
					((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top - 7)),
					((java_cup.runtime.Symbol) CUP$parser$stack.peek()), RESULT);
		}
			return CUP$parser$result;

		/* . . . . . . . . . . . . . . . . . . . . */
		case 20: // assignment_stmt ::= id ASSIGNOP expression
		{
			Object RESULT = null;

			CUP$parser$result = parser.getSymbolFactory().newSymbol("assignment_stmt", 14,
					((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top - 2)),
					((java_cup.runtime.Symbol) CUP$parser$stack.peek()), RESULT);
		}
			return CUP$parser$result;

		/* . . . . . . . . . . . . . . . . . . . . */
		case 19: // read_stmt ::= READ LBRECKET id RBRECKET
		{
			Object RESULT = null;

			CUP$parser$result = parser.getSymbolFactory().newSymbol("read_stmt", 0,
					((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top - 3)),
					((java_cup.runtime.Symbol) CUP$parser$stack.peek()), RESULT);
		}
			return CUP$parser$result;

		/* . . . . . . . . . . . . . . . . . . . . */
		case 18: // write_stmt ::= PRINT LBRECKET expression RBRECKET
		{
			Object RESULT = null;

			CUP$parser$result = parser.getSymbolFactory().newSymbol("write_stmt", 15,
					((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top - 3)),
					((java_cup.runtime.Symbol) CUP$parser$stack.peek()), RESULT);
		}
			return CUP$parser$result;

		/* . . . . . . . . . . . . . . . . . . . . */
		case 17: // stmt ::= stmt_block
		{
			Object RESULT = null;

			CUP$parser$result = parser.getSymbolFactory().newSymbol("stmt", 10,
					((java_cup.runtime.Symbol) CUP$parser$stack.peek()),
					((java_cup.runtime.Symbol) CUP$parser$stack.peek()), RESULT);
		}
			return CUP$parser$result;

		/* . . . . . . . . . . . . . . . . . . . . */
		case 16: // stmt ::= write_stmt
		{
			Object RESULT = null;

			CUP$parser$result = parser.getSymbolFactory().newSymbol("stmt", 10,
					((java_cup.runtime.Symbol) CUP$parser$stack.peek()),
					((java_cup.runtime.Symbol) CUP$parser$stack.peek()), RESULT);
		}
			return CUP$parser$result;

		/* . . . . . . . . . . . . . . . . . . . . */
		case 15: // stmt ::= read_stmt
		{
			Object RESULT = null;

			CUP$parser$result = parser.getSymbolFactory().newSymbol("stmt", 10,
					((java_cup.runtime.Symbol) CUP$parser$stack.peek()),
					((java_cup.runtime.Symbol) CUP$parser$stack.peek()), RESULT);
		}
			return CUP$parser$result;

		/* . . . . . . . . . . . . . . . . . . . . */
		case 14: // stmt ::= control_stmt
		{
			Object RESULT = null;

			CUP$parser$result = parser.getSymbolFactory().newSymbol("stmt", 10,
					((java_cup.runtime.Symbol) CUP$parser$stack.peek()),
					((java_cup.runtime.Symbol) CUP$parser$stack.peek()), RESULT);
		}
			return CUP$parser$result;

		/* . . . . . . . . . . . . . . . . . . . . */
		case 13: // stmt ::= id ASSIGNOP VAL
		{
			Object RESULT = null;

			CUP$parser$result = parser.getSymbolFactory().newSymbol("stmt", 10,
					((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top - 2)),
					((java_cup.runtime.Symbol) CUP$parser$stack.peek()), RESULT);
		}
			return CUP$parser$result;

		/* . . . . . . . . . . . . . . . . . . . . */
		case 12: // stmt ::= assignment_stmt
		{
			Object RESULT = null;

			CUP$parser$result = parser.getSymbolFactory().newSymbol("stmt", 10,
					((java_cup.runtime.Symbol) CUP$parser$stack.peek()),
					((java_cup.runtime.Symbol) CUP$parser$stack.peek()), RESULT);
		}
			return CUP$parser$result;

		/* . . . . . . . . . . . . . . . . . . . . */
		case 11: // cdecl ::=
		{
			Object RESULT = null;

			CUP$parser$result = parser.getSymbolFactory().newSymbol("cdecl", 8,
					((java_cup.runtime.Symbol) CUP$parser$stack.peek()),
					((java_cup.runtime.Symbol) CUP$parser$stack.peek()), RESULT);
		}
			return CUP$parser$result;

		/* . . . . . . . . . . . . . . . . . . . . */
		case 10: // cdecl ::= CONST type id ASSIGNOP NUM cdecl
		{
			Object RESULT = null;

			CUP$parser$result = parser.getSymbolFactory().newSymbol("cdecl", 8,
					((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top - 5)),
					((java_cup.runtime.Symbol) CUP$parser$stack.peek()), RESULT);
		}
			return CUP$parser$result;

		/* . . . . . . . . . . . . . . . . . . . . */
		case 9: // type ::= REAL
		{
			Object RESULT = null;

			CUP$parser$result = parser.getSymbolFactory().newSymbol("type", 7,
					((java_cup.runtime.Symbol) CUP$parser$stack.peek()),
					((java_cup.runtime.Symbol) CUP$parser$stack.peek()), RESULT);
		}
			return CUP$parser$result;

		/* . . . . . . . . . . . . . . . . . . . . */
		case 8: // type ::= INT
		{
			Object RESULT = null;

			CUP$parser$result = parser.getSymbolFactory().newSymbol("type", 7,
					((java_cup.runtime.Symbol) CUP$parser$stack.peek()),
					((java_cup.runtime.Symbol) CUP$parser$stack.peek()), RESULT);
		}
			return CUP$parser$result;

		/* . . . . . . . . . . . . . . . . . . . . */
		case 7: // decl ::= COLON type
		{
			Object RESULT = null;

			CUP$parser$result = parser.getSymbolFactory().newSymbol("decl", 6,
					((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top - 1)),
					((java_cup.runtime.Symbol) CUP$parser$stack.peek()), RESULT);
		}
			return CUP$parser$result;

		/* . . . . . . . . . . . . . . . . . . . . */
		case 6: // decl ::= COMMA id decl
		{
			Object RESULT = null;

			CUP$parser$result = parser.getSymbolFactory().newSymbol("decl", 6,
					((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top - 2)),
					((java_cup.runtime.Symbol) CUP$parser$stack.peek()), RESULT);
		}
			return CUP$parser$result;

		/* . . . . . . . . . . . . . . . . . . . . */
		case 5: // declarlist ::= id COLON decl
		{
			Object RESULT = null;

			CUP$parser$result = parser.getSymbolFactory().newSymbol("declarlist", 5,
					((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top - 2)),
					((java_cup.runtime.Symbol) CUP$parser$stack.peek()), RESULT);
		}
			return CUP$parser$result;

		/* . . . . . . . . . . . . . . . . . . . . */
		case 4: // declarlist ::= declarlist id decl
		{
			Object RESULT = null;

			CUP$parser$result = parser.getSymbolFactory().newSymbol("declarlist", 5,
					((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top - 2)),
					((java_cup.runtime.Symbol) CUP$parser$stack.peek()), RESULT);
		}
			return CUP$parser$result;

		/* . . . . . . . . . . . . . . . . . . . . */
		case 3: // declarations ::=
		{
			Object RESULT = null;

			CUP$parser$result = parser.getSymbolFactory().newSymbol("declarations", 3,
					((java_cup.runtime.Symbol) CUP$parser$stack.peek()),
					((java_cup.runtime.Symbol) CUP$parser$stack.peek()), RESULT);
		}
			return CUP$parser$result;

		/* . . . . . . . . . . . . . . . . . . . . */
		case 2: // declarations ::= VAR declarlist cdecl
		{
			Object RESULT = null;

			CUP$parser$result = parser.getSymbolFactory().newSymbol("declarations", 3,
					((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top - 2)),
					((java_cup.runtime.Symbol) CUP$parser$stack.peek()), RESULT);
		}
			return CUP$parser$result;

		/* . . . . . . . . . . . . . . . . . . . . */
		case 1: // $START ::= program EOF
		{
			Object RESULT = null;
			int start_valleft = ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top - 1)).left;
			int start_valright = ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top - 1)).right;
			Object start_val = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack
					.elementAt(CUP$parser$top - 1)).value;
			RESULT = start_val;
			CUP$parser$result = parser.getSymbolFactory().newSymbol("$START", 0,
					((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top - 1)),
					((java_cup.runtime.Symbol) CUP$parser$stack.peek()), RESULT);
		}
			/* ACCEPT */
			CUP$parser$parser.done_parsing();
			return CUP$parser$result;

		/* . . . . . . . . . . . . . . . . . . . . */
		case 0: // program ::= MAIN id START declarations stmtlist TRATS
		{
			Object RESULT = null;

			CUP$parser$result = parser.getSymbolFactory().newSymbol("program", 2,
					((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top - 5)),
					((java_cup.runtime.Symbol) CUP$parser$stack.peek()), RESULT);
		}
			return CUP$parser$result;

		/* . . . . . . */
		default:
			throw new Exception("Invalid action number found in internal parse table");

		}
	}
}
